type BulkItemError {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """Index of an input list item that caused the error."""
  index: Int

  """The error message."""
  message: String
}

type Category implements Node {
  created: DateTime!
  customId: ID

  """The ID of the object."""
  id: ID!
  name: String!
  slug: String!
  updated: DateTime!
  vehicles(after: String, before: String, first: Int, last: Int): VehiclesConnection
}

"""Deletes categories."""
type CategoryBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type CategoryConnection {
  """Contains the nodes in this connection."""
  edges: [CategoryEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

type CategoryCreate {
  category: Category
  errors: [Error!]!
}

type CategoryDelete {
  category: Category
  errors: [Error!]!
}

"""A Relay edge containing a `Category` and its cursor."""
type CategoryEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Category
}

input CategoryInput {
  name: String
  slug: String
}

enum CategorySortField {
  NAME
}

input CategorySortingInput {
  direction: OrderDirection!

  """Sort categories by the selected field."""
  field: CategorySortField!
}

type CategoryUpdate {
  category: Category
  errors: [Error!]!
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type Document implements Node {
  beginDate: Date
  created: DateTime!
  description: String!
  expirationDate: Date
  expires: Boolean!
  file: String!

  """The ID of the object."""
  id: ID!
  isPublished: Boolean!
  name: String!
  provider: Provider!
  publicationDate: Date
  updated: DateTime!
}

type DocumentConnection {
  """Contains the nodes in this connection."""
  edges: [DocumentEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

type DocumentCreate {
  document: Document
  errors: [Error!]!
}

type DocumentDelete {
  document: Document
  errors: [Error!]!
}

"""A Relay edge containing a `Document` and its cursor."""
type DocumentEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Document
}

input DocumentInput {
  beginDate: Date
  description: String
  expirationDate: Date
  expires: Boolean
  file: Upload
  isPublished: Boolean
  name: String
  provider: ID
  publicationDate: Date
}

type DocumentUpdate {
  document: Document
  errors: [Error!]!
}

type DocumentsConnection {
  """Contains the nodes in this connection."""
  edges: [DocumentsEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `Documents` and its cursor."""
type DocumentsEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Document
}

"""Represents an error in the input of a mutation."""
type Error {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """The error message."""
  message: String
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

type Investment implements Node {
  created: DateTime!

  """The ID of the object."""
  id: ID!
  isPublished: Boolean!
  items: [Item]
  month: Int!
  publicationDate: Date
  updated: DateTime!
  year: Int!
}

"""Deletes segments."""
type InvestmentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type InvestmentConnection {
  """Contains the nodes in this connection."""
  edges: [InvestmentEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

type InvestmentCreate {
  errors: [Error!]!
  investment: Investment
}

type InvestmentDelete {
  errors: [Error!]!
  investment: Investment
}

"""A Relay edge containing a `Investment` and its cursor."""
type InvestmentEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Investment
}

input InvestmentInput {
  isPublished: Boolean
  items: [ItemCreateInput!]
  month: Int
  year: Int
}

type InvestmentUpdate {
  errors: [Error!]!
  investment: Investment
}

input InvestmentUpdateInput {
  addItems: [ItemCreateInput!]
  isPublished: Boolean
  month: Int
  removeItems: [ID!]
  year: Int
}

type Item implements Node {
  """The ID of the object."""
  id: ID!
  investment: Investment!
  name: String!
  value: Decimal!
}

type ItemBulkCreate {
  errors: [BulkItemError!]!
  items: [Item]
}

input ItemBulkInput {
  name: String
  value: Float
}

type ItemCreate {
  errors: [Error!]!
  investment: Investment
  item: Item
}

input ItemCreateInput {
  name: String!
  value: Float!
}

type ItemDelete {
  errors: [Error!]!
  item: Item
}

input ItemInput {
  investment: ID
  name: String
  value: Float
}

type ItemUpdate {
  errors: [Error!]!
  item: Item
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

type Mutation {
  """Deletes categories."""
  categoryBulkDelete(
    """List of category IDs to delete."""
    ids: [ID!]!
  ): CategoryBulkDelete
  categoryCreate(input: CategoryInput!): CategoryCreate
  categoryDelete(id: ID): CategoryDelete
  categoryUpdate(id: ID, input: CategoryInput!): CategoryUpdate
  documentCreate(input: DocumentInput!): DocumentCreate
  documentDelete(id: ID): DocumentDelete
  documentUpdate(id: ID, input: DocumentInput!): DocumentUpdate

  """Deletes segments."""
  investmentBulkDelete(
    """List of segments IDs to delete."""
    ids: [ID!]!
  ): InvestmentBulkDelete
  investmentCreate(input: InvestmentInput!): InvestmentCreate
  investmentDelete(id: ID): InvestmentDelete
  investmentUpdate(id: ID, input: InvestmentUpdateInput!): InvestmentUpdate
  itemBulkCreate(investmentId: ID, items: [ItemBulkInput]!): ItemBulkCreate
  itemCreate(input: ItemInput!, investmentId: ID!): ItemCreate
  itemDelete(id: ID): ItemDelete
  itemUpdate(id: ID, input: ItemInput!): ItemUpdate

  """Deletes providers."""
  providerBulkDelete(
    """List of providers IDs to delete."""
    ids: [ID!]!
  ): ProviderBulkDelete
  providerCreate(input: ProviderInput!): ProviderCreate
  providerDelete(id: ID): ProviderDelete
  providerUpdate(id: ID, input: ProviderInput!): ProviderUpdate
  refreshToken(token: String): Refresh

  """Deletes segments."""
  segmentBulkDelete(
    """List of segments IDs to delete."""
    ids: [ID!]!
  ): SegmentBulkDelete
  segmentCreate(input: SegmentInput!): SegmentCreate
  segmentDelete(id: ID): SegmentDelete
  segmentUpdate(id: ID, input: SegmentInput!): SegmentUpdate

  """Deletes sessions."""
  sessionBulkDelete(
    """List of sessions IDs to delete."""
    ids: [ID!]!
  ): SessionBulkDelete
  sessionCreate(input: SessionInput!): SessionCreate
  sessionDelete(id: ID): SessionDelete
  sessionUpdate(id: ID, input: SessionInput!): SessionUpdate
  tokenAuth(email: String, password: String): ObtainJSONWebToken

  """Deletes vehicles."""
  vehicleBulkDelete(
    """List of vehicles IDs to delete."""
    ids: [ID!]!
  ): VehicleBulkDelete
  vehicleCreate(input: VehicleInput!): VehicleCreate
  vehicleDelete(id: ID): VehicleDelete
  vehicleUpdate(id: ID, input: VehicleInput!): VehicleUpdate
  verifyToken(token: String): Verify
}

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

type ObtainJSONWebToken {
  errors: [Error!]!
  token: String
  user: User
}

enum OrderDirection {
  ASC
  DESC
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

"""Represents a permission object in a friendly form."""
type Permission {
  """Internal code for permission."""
  code: String!

  """Describe action(s) allowed to do by permission."""
  name: String!
}

type Provider implements Node {
  created: DateTime!
  documentNumber: String!
  documents(after: String, before: String, first: Int, last: Int): DocumentsConnection

  """The ID of the object."""
  id: ID!
  isPublished: Boolean!
  name: String!
  publicationDate: Date
  segment: Segment!
  slug: String!
  updated: DateTime!
}

"""Deletes providers."""
type ProviderBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type ProviderConnection {
  """Contains the nodes in this connection."""
  edges: [ProviderEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

type ProviderCreate {
  errors: [Error!]!
  provider: Provider
}

type ProviderDelete {
  errors: [Error!]!
  provider: Provider
}

"""A Relay edge containing a `Provider` and its cursor."""
type ProviderEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Provider
}

input ProviderInput {
  documentNumber: String
  isPublished: Boolean
  name: String
  publicationDate: Date
  segment: ID
  slug: String
}

enum ProviderSortField {
  CREATED
  NAME
  PUBLISHED
  UPDATED
}

input ProviderSortingInput {
  direction: OrderDirection!

  """Sort providers by the selected field."""
  field: ProviderSortField!
}

type ProviderUpdate {
  errors: [Error!]!
  provider: Provider
  vehicle: Provider
}

type ProvidersConnection {
  """Contains the nodes in this connection."""
  edges: [ProvidersEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `Providers` and its cursor."""
type ProvidersEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Provider
}

type Query {
  categories(after: String, before: String, first: Int, last: Int, offset: Int, search: String, sortBy: CategorySortingInput): CategoryConnection
  category(id: ID, slug: String): Category
  document(id: ID): Document
  documents(after: String, before: String, beginDate: Date, beginDate_Gte: Date, beginDate_Lte: Date, expirationDate: Date, expirationDate_Gte: Date, expirationDate_Lte: Date, expires: Boolean, first: Int, isPublished: Boolean, last: Int, offset: Int, search: String): DocumentConnection
  investment(id: ID, month: Int, year: Int): Investment
  investments(after: String, before: String, first: Int, isPublished: Boolean, last: Int, month: Int, offset: Int, year: Int): InvestmentConnection
  me: User
  provider(id: ID, slug: String): Provider
  providers(after: String, before: String, first: Int, isPublished: Boolean, last: Int, offset: Int, search: String, segment: ID, sortBy: ProviderSortingInput): ProviderConnection
  segment(id: ID, slug: String): Segment
  segments(after: String, before: String, first: Int, last: Int, offset: Int, search: String, sortBy: SegmentSortingInput): SegmentConnection
  session(id: ID, slug: String): Session
  sessions(after: String, before: String, first: Int, isPublished: Boolean, last: Int, offset: Int, search: String): SessionConnection
  vehicle(id: ID, slug: String): Vehicle
  vehicles(after: String, before: String, category: ID, first: Int, isPublished: Boolean, last: Int, offset: Int, search: String): VehicleConnection
}

type Refresh {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
}

type Segment implements Node {
  created: DateTime!

  """The ID of the object."""
  id: ID!
  name: String!
  providers(after: String, before: String, first: Int, last: Int): ProvidersConnection
  slug: String!
  updated: DateTime!
}

"""Deletes segments."""
type SegmentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type SegmentConnection {
  """Contains the nodes in this connection."""
  edges: [SegmentEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

type SegmentCreate {
  errors: [Error!]!
  segment: Segment
}

type SegmentDelete {
  errors: [Error!]!
  segment: Segment
}

"""A Relay edge containing a `Segment` and its cursor."""
type SegmentEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Segment
}

input SegmentInput {
  name: String
  slug: String
}

enum SegmentSortField {
  NAME
}

input SegmentSortingInput {
  direction: OrderDirection!

  """Sort segments by the selected field."""
  field: SegmentSortField!
}

type SegmentUpdate {
  errors: [Error!]!
  segment: Segment
}

type Session implements Node {
  content: JSONString
  created: DateTime!
  date: DateTime!

  """The ID of the object."""
  id: ID!
  isPublished: Boolean!
  name: String!
  publicationDate: Date
  slug: String!
  updated: DateTime!
}

"""Deletes sessions."""
type SessionBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type SessionConnection {
  """Contains the nodes in this connection."""
  edges: [SessionEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

type SessionCreate {
  errors: [Error!]!
  session: Session
}

type SessionDelete {
  errors: [Error!]!
  session: Session
}

"""A Relay edge containing a `Session` and its cursor."""
type SessionEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Session
}

input SessionInput {
  content: JSONString
  date: DateTime
  isPublished: Boolean
  name: String
  slug: String
}

type SessionUpdate {
  errors: [Error!]!
  session: Session
  vehicle: Session
}

"""
Create scalar that ignores normal serialization/deserialization, since
that will be handled by the multipart request spec
"""
scalar Upload

type User implements Node {
  dateJoined: DateTime!
  email: String!
  firstName: String!

  """The ID of the object."""
  id: ID!
  isActive: Boolean!
  isStaff: Boolean!

  """
  Indica que este usuário tem todas as permissões sem atribuí-las explicitamente.
  """
  isSuperuser: Boolean!
  jwtTokenKey: String!
  lastLogin: DateTime
  lastName: String!
  password: String!
  permissions: [Permission]
  updatedAt: DateTime!
}

type Vehicle implements Node {
  category: Category!
  created: DateTime!
  documentFile: String!
  documentNumber: String!

  """The ID of the object."""
  id: ID!
  isPublished: Boolean!
  name: String!
  publicationDate: Date
  slug: String!
  updated: DateTime!
}

"""Deletes vehicles."""
type VehicleBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type VehicleConnection {
  """Contains the nodes in this connection."""
  edges: [VehicleEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

type VehicleCreate {
  errors: [Error!]!
  vehicle: Vehicle
}

type VehicleDelete {
  errors: [Error!]!
  vehicle: Vehicle
}

"""A Relay edge containing a `Vehicle` and its cursor."""
type VehicleEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Vehicle
}

input VehicleInput {
  category: ID
  documentNumber: String
  isPublished: Boolean
  name: String
  publicationDate: Date
  slug: String
}

type VehicleUpdate {
  errors: [Error!]!
  vehicle: Vehicle
}

type VehiclesConnection {
  """Contains the nodes in this connection."""
  edges: [VehiclesEdge]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!
  totalCount: Int
}

"""A Relay edge containing a `Vehicles` and its cursor."""
type VehiclesEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Vehicle
}

type Verify {
  payload: GenericScalar!
}