type BulkItemError {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """Index of an input list item that caused the error."""
  index: Int

  """The error message."""
  message: String
}

type Category implements Node {
  entries(after: String, before: String, first: Int, last: Int): EntryCountableConnection
  id: ID!
  name: String!
  slug: String
  totalEntries: Int
}

"""Deletes categories."""
type CategoryBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type CategoryCountableConnection {
  edges: [CategoryCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type CategoryCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Category!
}

type CategoryCreate {
  category: Category
  errors: [Error!]!
}

type CategoryDelete {
  category: Category
  errors: [Error!]!
}

input CategoryFilterInput {
  search: String
}

input CategoryInput {
  name: String
  slug: String
}

enum CategorySortField {
  NAME
}

input CategorySortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort categories by the selected field."""
  field: CategorySortField!
}

type CategoryUpdate {
  category: Category
  errors: [Error!]!
}

"""Represents channel."""
type Channel implements Node {
  id: ID!

  """Whether the channel is active."""
  isActive: Boolean!

  """Name of the channel."""
  name: String!

  """Slug of the channel."""
  slug: String!
}

type ChannelActivate {
  channel: Channel
  errors: [Error!]!
}

type ChannelCreate {
  channel: Channel
  errors: [Error!]!
}

type ChannelDeactivate {
  channel: Channel
  errors: [Error!]!
}

type ChannelDelete {
  channel: Channel
  errors: [Error!]!
}

input ChannelInput {
  isActive: Boolean
  name: String!
  slug: String!
}

type ChannelUpdate {
  channel: Channel
  errors: [Error!]!
}

type ConfigurationItem {
  helpText: String
  label: String
  name: String!
  type: ConfigurationTypeFieldEnum
  value: String
}

input ConfigurationItemInput {
  name: String!
  value: String
}

"""An enumeration."""
enum ConfigurationTypeFieldEnum {
  BOOLEAN
  MULTILINE
  OUTPUT
  PASSWORD
  SECRET
  SECRETMULTILINE
  STRING
}

"""Create JWT token."""
type CreateToken {
  """CSRF token required to re-generate access token."""
  csrfToken: String
  errors: [Error!]!

  """JWT refresh token, required to re-generate access token."""
  refreshToken: String

  """JWT token, required to authenticate."""
  token: String

  """A user instance."""
  user: User
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

input DateRangeInput {
  """Start date."""
  gte: Date

  """End date."""
  lte: Date
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""Deactivate all JWT tokens of the currently authenticated user."""
type DeactivateAllUserTokens {
  errors: [Error!]!
}

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type Document implements Node {
  created: DateTime
  defaultFile: DocumentFile
  description: String
  entry: Entry
  expired: Boolean
  expires: Boolean
  files: [DocumentFile!]
  id: ID!
  isPublished: Boolean
  name: String!
  publicationDate: Date
  updated: DateTime
}

"""Deletes segments."""
type DocumentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type DocumentCountableConnection {
  edges: [DocumentCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type DocumentCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Document!
}

type DocumentCreate {
  document: Document
  errors: [Error!]!
}

type DocumentDelete {
  document: Document
  errors: [Error!]!
}

type DocumentFile implements Node {
  beginDate: Date
  created: DateTime
  document: Document
  expirationDate: Date
  file: File

  """The ID of the object."""
  id: ID!
  updated: DateTime
}

input DocumentFilterInput {
  beginDate: DateRangeInput
  expirationDate: DateRangeInput
  expires: Boolean
  isPublished: Boolean
  search: String
  type: EntryTypeEnum
}

input DocumentInput {
  beginDate: Date
  description: String
  entry: ID
  expirationDate: Date
  expires: Boolean
  file: Upload
  isPublished: Boolean
  name: String
  provider: ID
  publicationDate: Date
}

enum DocumentSortField {
  CREATED
}

input DocumentSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort documents by the selected field."""
  field: DocumentSortField!
}

type DocumentUpdate {
  document: Document
  errors: [Error!]!
}

type Entry implements Node {
  address: String
  category: Category
  documentNumber: String
  documents(after: String, before: String, first: Int, last: Int): DocumentCountableConnection
  email: String
  id: ID!
  isPublished: Boolean
  name: String!
  phone: String
  slug: String
  type: EntryTypeEnum
}

"""Deletes entries."""
type EntryBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type EntryCountableConnection {
  edges: [EntryCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type EntryCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Entry!
}

type EntryCreate {
  entry: Entry
  errors: [Error!]!
}

type EntryDelete {
  entry: Entry
  errors: [Error!]!
}

input EntryFilterInput {
  categories: [ID!]
  category: ID
  isPublished: Boolean
  search: String
  type: EntryTypeEnum
}

input EntryInput {
  address: String
  category: ID
  documentNumber: String
  email: String
  isPublished: Boolean
  name: String
  phone: String
  publicationDate: Date
  slug: String
}

enum EntrySortField {
  CREATED
  NAME
  PUBLISHED
  UPDATED
}

input EntrySortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort entries by the selected field."""
  field: EntrySortField!
}

"""An enumeration."""
enum EntryTypeEnum {
  PROVIDER
  VEHICLE
}

type EntryUpdate {
  entry: Entry
  errors: [Error!]!
}

"""Represents an error in the input of a mutation."""
type Error {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """The error message."""
  message: String
}

type File {
  url: String!
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

type Investment implements Node {
  id: ID!
  isPublished: Boolean
  items: [Item!]
  month: Int!
  year: Int!
}

"""Deletes segments."""
type InvestmentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type InvestmentCountableConnection {
  edges: [InvestmentCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type InvestmentCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Investment!
}

type InvestmentCreate {
  errors: [Error!]!
  investment: Investment
}

type InvestmentDelete {
  errors: [Error!]!
  investment: Investment
}

input InvestmentFilterInput {
  isPublished: Boolean
  month: Float
  year: Float
}

input InvestmentInput {
  isPublished: Boolean
  items: [ItemCreateInput!]
  month: Int
  year: Int
}

enum InvestmentSortField {
  CREATED
}

input InvestmentSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort investments by the selected field."""
  field: InvestmentSortField!
}

type InvestmentUpdate {
  errors: [Error!]!
  investment: Investment
}

input InvestmentUpdateInput {
  addItems: [ItemCreateInput!]
  isPublished: Boolean
  month: Int
  removeItems: [ID!]
  year: Int
}

type Item implements Node {
  id: ID!
  investment: Investment
  name: String!
  value: Decimal
}

type ItemBulkCreate {
  errors: [BulkItemError!]!
  items: [Item]
}

input ItemBulkInput {
  name: String
  value: Float
}

type ItemCreate {
  errors: [Error!]!
  investment: Item
  item: Item
}

input ItemCreateInput {
  name: String!
  value: Float!
}

type ItemDelete {
  errors: [Error!]!
  item: Item
}

input ItemInput {
  investment: ID
  name: String
  value: Float
}

type ItemUpdate {
  errors: [Error!]!
  item: Item
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

type Mutation {
  """Deletes categories."""
  categoryBulkDelete(
    """List of category IDs to delete."""
    ids: [ID!]!
  ): CategoryBulkDelete
  categoryCreate(input: CategoryInput!): CategoryCreate
  categoryDelete(id: ID): CategoryDelete
  categoryUpdate(id: ID, input: CategoryInput!): CategoryUpdate
  channelActivate(id: ID!): ChannelActivate
  channelCreate(input: ChannelInput!): ChannelCreate
  channelDeactivate(id: ID!): ChannelDeactivate
  channelDelete(
    """ID of a channel to delete."""
    id: ID!
  ): ChannelDelete
  channelUpdate(id: ID!, input: ChannelInput!): ChannelUpdate

  """Deletes segments."""
  documentBulkDelete(
    """List of documents IDs to delete."""
    ids: [ID!]!
  ): DocumentBulkDelete
  documentCreate(input: DocumentInput!): DocumentCreate
  documentDelete(id: ID): DocumentDelete
  documentUpdate(id: ID, input: DocumentInput!): DocumentUpdate

  """Deletes entries."""
  entryBulkDelete(
    """List of entries IDs to delete."""
    ids: [ID!]!
  ): EntryBulkDelete
  entryCreate(input: EntryInput!, type: EntryTypeEnum): EntryCreate
  entryDelete(id: ID): EntryDelete
  entryUpdate(id: ID, input: EntryInput!): EntryUpdate

  """Deletes segments."""
  investmentBulkDelete(
    """List of segments IDs to delete."""
    ids: [ID!]!
  ): InvestmentBulkDelete
  investmentCreate(input: InvestmentInput!): InvestmentCreate
  investmentDelete(id: ID): InvestmentDelete
  investmentUpdate(id: ID, input: InvestmentUpdateInput!): InvestmentUpdate
  itemBulkCreate(investmentId: ID, items: [ItemBulkInput]!): ItemBulkCreate
  itemCreate(input: ItemInput!, investmentId: ID!): ItemCreate
  itemDelete(id: ID): ItemDelete
  itemUpdate(id: ID, input: ItemInput!): ItemUpdate
  passwordReset(email: String!, password: String!, token: String!): SetPassword
  pluginUpdate(channelId: ID, id: ID!, input: PluginUpdateInput!): PluginUpdate
  requestPasswordReset(email: String!, redirectUrl: String!): RequestPasswordReset

  """Deletes sessions."""
  sessionBulkDelete(
    """List of sessions IDs to delete."""
    ids: [ID!]!
  ): SessionBulkDelete
  sessionCreate(input: SessionInput!): SessionCreate
  sessionDelete(id: ID): SessionDelete
  sessionUpdate(id: ID, input: SessionInput!): SessionUpdate

  """Create JWT token."""
  tokenCreate(
    """Email of a user."""
    email: String!

    """Password of a user."""
    password: String!
  ): CreateToken

  """
  Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie.
  """
  tokenRefresh(
    """
    CSRF token required to refresh token. This argument is required when refreshToken is provided as a cookie.
    """
    csrfToken: String

    """Refresh token."""
    refreshToken: String
  ): RefreshToken

  """Verify JWT token."""
  tokenVerify(
    """JWT token to validate."""
    token: String!
  ): VerifyToken

  """Deactivate all JWT tokens of the currently authenticated user."""
  tokensDeactivateAll: DeactivateAllUserTokens
}

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

enum OrderDirection {
  """Specifies an ascending sort order."""
  ASC

  """Specifies a descending sort order."""
  DESC
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

"""Represents a permission object in a friendly form."""
type Permission {
  """Internal code for permission."""
  code: String!

  """Describe action(s) allowed to do by permission."""
  name: String!
}

"""Plugin."""
type Plugin {
  channelConfigurations: [PluginConfiguration!]!
  description: String!
  globalConfiguration: PluginConfiguration
  id: ID!
  name: String!
}

type PluginConfiguration {
  active: Boolean!
  channel: Channel
  configuration: [ConfigurationItem!]
}

enum PluginConfigurationType {
  GLOBAL
  PER_CHANNEL
}

type PluginCountableConnection {
  edges: [PluginCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type PluginCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Plugin!
}

input PluginFilterInput {
  search: String
  statusInChannels: PluginStatusInChannelsInput
  type: PluginConfigurationType
}

enum PluginSortField {
  IS_ACTIVE
  NAME
}

input PluginSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort plugins by the selected field."""
  field: PluginSortField!
}

input PluginStatusInChannelsInput {
  active: Boolean!
  channels: [ID!]!
}

type PluginUpdate {
  errors: [Error!]!
  plugin: Plugin
}

input PluginUpdateInput {
  active: Boolean
  configuration: [ConfigurationItemInput!]
}

type Query {
  categories(after: String, before: String, filter: CategoryFilterInput, first: Int, last: Int, sortBy: CategorySortingInput): CategoryCountableConnection
  category(id: ID, slug: String): Category

  """Look up a channel by ID or slug."""
  channel(
    """ID of the channel."""
    id: ID

    """Slug of the channel."""
    slug: String
  ): Channel

  """List of all channels."""
  channels: [Channel!]
  document(id: ID): Document
  documents(after: String, before: String, filter: DocumentFilterInput, first: Int, last: Int, sortBy: DocumentSortingInput): DocumentCountableConnection
  entries(after: String, before: String, filter: EntryFilterInput, first: Int, last: Int, sortBy: EntrySortingInput): EntryCountableConnection
  entry(id: ID, slug: String): Entry
  investment(id: ID, month: Int, year: Int): Investment
  investments(after: String, before: String, filter: InvestmentFilterInput, first: Int, last: Int, sortBy: InvestmentSortingInput): InvestmentCountableConnection
  me: User
  plugin(id: ID!): Plugin
  plugins(after: String, before: String, filter: PluginFilterInput, first: Int, last: Int, sortBy: PluginSortingInput): PluginCountableConnection
  session(id: ID, slug: String): Session
  sessions(after: String, before: String, filter: SessionFilterInput, first: Int, last: Int, sortBy: SessionSortingInput): SessionCountableConnection
}

"""
Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie.
"""
type RefreshToken {
  errors: [Error!]!

  """JWT token, required to authenticate."""
  token: String

  """A user instance."""
  user: User
}

type RequestPasswordReset {
  errors: [Error!]!
}

type Session implements Node {
  content: JSONString
  date: DateTime
  id: ID!
  isPublished: Boolean
  name: String!
  slug: String
}

"""Deletes sessions."""
type SessionBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type SessionCountableConnection {
  edges: [SessionCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type SessionCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Session!
}

type SessionCreate {
  errors: [Error!]!
  session: Session
}

type SessionDelete {
  errors: [Error!]!
  session: Session
}

input SessionFilterInput {
  isPublished: Boolean
  search: String
}

input SessionInput {
  content: JSONString
  date: DateTime
  isPublished: Boolean
  name: String
  slug: String
}

enum SessionSortField {
  NAME
}

input SessionSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort sessions by the selected field."""
  field: SessionSortField!
}

type SessionUpdate {
  entry: Session
  errors: [Error!]!
  session: Session
}

type SetPassword {
  errors: [Error!]!
}

"""
Create scalar that ignores normal serialization/deserialization, since
that will be handled by the multipart request spec
"""
scalar Upload

type User implements Node {
  email: String!
  firstName: String
  id: ID!
  isStaff: Boolean
  lastName: String
  permissions: [Permission]
}

"""Verify JWT token."""
type VerifyToken {
  errors: [Error!]!

  """Determine if token is valid or not."""
  isValid: Boolean!

  """JWT payload."""
  payload: GenericScalar

  """User assigned to token."""
  user: User
}