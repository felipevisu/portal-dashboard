type BulkItemError {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """Index of an input list item that caused the error."""
  index: Int

  """The error message."""
  message: String
}

type Category implements Node {
  entries(after: String, before: String, first: Int, last: Int): EntryCountableConnection
  id: ID!
  name: String!
  slug: String
  totalEntries: Int
  type: EntryTypeEnum
}

"""Deletes categories."""
type CategoryBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type CategoryCountableConnection {
  edges: [CategoryCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type CategoryCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Category!
}

type CategoryCreate {
  category: Category
  errors: [Error!]!
}

type CategoryDelete {
  category: Category
  errors: [Error!]!
}

input CategoryFilterInput {
  search: String
  type: EntryTypeEnum
}

input CategoryInput {
  name: String
  slug: String
  type: EntryTypeEnum
}

enum CategorySortField {
  NAME
}

input CategorySortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort categories by the selected field."""
  field: CategorySortField!
}

type CategoryUpdate {
  category: Category
  errors: [Error!]!
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

input DateRangeInput {
  """Start date."""
  gte: Date

  """End date."""
  lte: Date
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type Document implements Node {
  beginDate: Date
  created: DateTime
  description: String
  entry: Entry
  expirationDate: Date
  expired: Boolean
  expires: Boolean
  file: File
  id: ID!
  isPublished: Boolean
  name: String!
  publicationDate: Date
  updated: DateTime
}

"""Deletes segments."""
type DocumentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type DocumentCountableConnection {
  edges: [DocumentCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type DocumentCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Document!
}

type DocumentCreate {
  document: Document
  errors: [Error!]!
}

type DocumentDelete {
  document: Document
  errors: [Error!]!
}

input DocumentFilterInput {
  beginDate: DateRangeInput
  expirationDate: DateRangeInput
  expires: Boolean
  isPublished: Boolean
  search: String
  type: EntryTypeEnum
}

input DocumentInput {
  beginDate: Date
  description: String
  entry: ID
  expirationDate: Date
  expires: Boolean
  file: Upload
  isPublished: Boolean
  name: String
  provider: ID
  publicationDate: Date
}

enum DocumentSortField {
  CREATED
}

input DocumentSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort documents by the selected field."""
  field: DocumentSortField!
}

type DocumentUpdate {
  document: Document
  errors: [Error!]!
}

type Entry implements Node {
  address: String
  category: Category
  documentNumber: String
  documents(after: String, before: String, first: Int, last: Int): DocumentCountableConnection
  email: String
  id: ID!
  isPublished: Boolean
  name: String!
  phone: String
  slug: String
  type: EntryTypeEnum
}

"""Deletes entries."""
type EntryBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type EntryCountableConnection {
  edges: [EntryCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type EntryCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Entry!
}

type EntryCreate {
  entry: Entry
  errors: [Error!]!
}

type EntryDelete {
  entry: Entry
  errors: [Error!]!
}

input EntryFilterInput {
  categories: [ID!]
  category: ID
  isPublished: Boolean
  search: String
  type: EntryTypeEnum
}

input EntryInput {
  address: String
  category: ID
  documentNumber: String
  email: String
  isPublished: Boolean
  name: String
  phone: String
  publicationDate: Date
  slug: String
}

enum EntrySortField {
  CREATED
  NAME
  PUBLISHED
  UPDATED
}

input EntrySortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort entries by the selected field."""
  field: EntrySortField!
}

"""An enumeration."""
enum EntryTypeEnum {
  PROVIDER
  VEHICLE
}

type EntryUpdate {
  entry: Entry
  errors: [Error!]!
}

"""Represents an error in the input of a mutation."""
type Error {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """The error message."""
  message: String
}

type File {
  url: String!
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

type Investment implements Node {
  id: ID!
  isPublished: Boolean
  items: [Item!]
  month: Int!
  year: Int!
}

"""Deletes segments."""
type InvestmentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type InvestmentCountableConnection {
  edges: [InvestmentCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type InvestmentCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Investment!
}

type InvestmentCreate {
  errors: [Error!]!
  investment: Investment
}

type InvestmentDelete {
  errors: [Error!]!
  investment: Investment
}

input InvestmentFilterInput {
  isPublished: Boolean
  month: Float
  year: Float
}

input InvestmentInput {
  isPublished: Boolean
  items: [ItemCreateInput!]
  month: Int
  year: Int
}

enum InvestmentSortField {
  CREATED
}

input InvestmentSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort investments by the selected field."""
  field: InvestmentSortField!
}

type InvestmentUpdate {
  errors: [Error!]!
  investment: Investment
}

input InvestmentUpdateInput {
  addItems: [ItemCreateInput!]
  isPublished: Boolean
  month: Int
  removeItems: [ID!]
  year: Int
}

type Item implements Node {
  id: ID!
  investment: Investment
  name: String!
  value: Decimal
}

type ItemBulkCreate {
  errors: [BulkItemError!]!
  items: [Item]
}

input ItemBulkInput {
  name: String
  value: Float
}

type ItemCreate {
  errors: [Error!]!
  investment: Item
  item: Item
}

input ItemCreateInput {
  name: String!
  value: Float!
}

type ItemDelete {
  errors: [Error!]!
  item: Item
}

input ItemInput {
  investment: ID
  name: String
  value: Float
}

type ItemUpdate {
  errors: [Error!]!
  item: Item
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

type Mutation {
  """Deletes categories."""
  categoryBulkDelete(
    """List of category IDs to delete."""
    ids: [ID!]!
  ): CategoryBulkDelete
  categoryCreate(input: CategoryInput!): CategoryCreate
  categoryDelete(id: ID): CategoryDelete
  categoryUpdate(id: ID, input: CategoryInput!): CategoryUpdate

  """Deletes segments."""
  documentBulkDelete(
    """List of documents IDs to delete."""
    ids: [ID!]!
  ): DocumentBulkDelete
  documentCreate(input: DocumentInput!): DocumentCreate
  documentDelete(id: ID): DocumentDelete
  documentUpdate(id: ID, input: DocumentInput!): DocumentUpdate

  """Deletes entries."""
  entryBulkDelete(
    """List of entries IDs to delete."""
    ids: [ID!]!
  ): EntryBulkDelete
  entryCreate(input: EntryInput!, type: EntryTypeEnum): EntryCreate
  entryDelete(id: ID): EntryDelete
  entryUpdate(id: ID, input: EntryInput!): EntryUpdate

  """Deletes segments."""
  investmentBulkDelete(
    """List of segments IDs to delete."""
    ids: [ID!]!
  ): InvestmentBulkDelete
  investmentCreate(input: InvestmentInput!): InvestmentCreate
  investmentDelete(id: ID): InvestmentDelete
  investmentUpdate(id: ID, input: InvestmentUpdateInput!): InvestmentUpdate
  itemBulkCreate(investmentId: ID, items: [ItemBulkInput]!): ItemBulkCreate
  itemCreate(input: ItemInput!, investmentId: ID!): ItemCreate
  itemDelete(id: ID): ItemDelete
  itemUpdate(id: ID, input: ItemInput!): ItemUpdate
  refreshToken(token: String): Refresh

  """Deletes sessions."""
  sessionBulkDelete(
    """List of sessions IDs to delete."""
    ids: [ID!]!
  ): SessionBulkDelete
  sessionCreate(input: SessionInput!): SessionCreate
  sessionDelete(id: ID): SessionDelete
  sessionUpdate(id: ID, input: SessionInput!): SessionUpdate
  tokenAuth(email: String, password: String): ObtainJSONWebToken
  verifyToken(token: String): Verify
}

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

type ObtainJSONWebToken {
  errors: [Error!]!
  token: String
  user: User
}

enum OrderDirection {
  """Specifies an ascending sort order."""
  ASC

  """Specifies a descending sort order."""
  DESC
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

"""Represents a permission object in a friendly form."""
type Permission {
  """Internal code for permission."""
  code: String!

  """Describe action(s) allowed to do by permission."""
  name: String!
}

type Query {
  categories(after: String, before: String, filter: CategoryFilterInput, first: Int, last: Int, sortBy: CategorySortingInput): CategoryCountableConnection
  category(id: ID, slug: String): Category
  document(id: ID): Document
  documents(after: String, before: String, filter: DocumentFilterInput, first: Int, last: Int, sortBy: DocumentSortingInput): DocumentCountableConnection
  entries(after: String, before: String, filter: EntryFilterInput, first: Int, last: Int, sortBy: EntrySortingInput): EntryCountableConnection
  entry(id: ID, slug: String): Entry
  investment(id: ID, month: Int, year: Int): Investment
  investments(after: String, before: String, filter: InvestmentFilterInput, first: Int, last: Int, sortBy: InvestmentSortingInput): InvestmentCountableConnection
  me: User
  session(id: ID, slug: String): Session
  sessions(after: String, before: String, filter: SessionFilterInput, first: Int, last: Int, sortBy: SessionSortingInput): SessionCountableConnection
}

type Refresh {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
}

type Session implements Node {
  content: JSONString
  date: DateTime
  id: ID!
  isPublished: Boolean
  name: String!
  slug: String
}

"""Deletes sessions."""
type SessionBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type SessionCountableConnection {
  edges: [SessionCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type SessionCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Session!
}

type SessionCreate {
  errors: [Error!]!
  session: Session
}

type SessionDelete {
  errors: [Error!]!
  session: Session
}

input SessionFilterInput {
  isPublished: Boolean
  search: String
}

input SessionInput {
  content: JSONString
  date: DateTime
  isPublished: Boolean
  name: String
  slug: String
}

enum SessionSortField {
  NAME
}

input SessionSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort sessions by the selected field."""
  field: SessionSortField!
}

type SessionUpdate {
  entry: Session
  errors: [Error!]!
  session: Session
}

"""
Create scalar that ignores normal serialization/deserialization, since
that will be handled by the multipart request spec
"""
scalar Upload

type User implements Node {
  email: String!
  firstName: String
  id: ID!
  isStaff: Boolean
  lastName: String
  permissions: [Permission]
}

type Verify {
  payload: GenericScalar!
}