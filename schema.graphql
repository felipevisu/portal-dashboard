type BulkItemError {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """Index of an input list item that caused the error."""
  index: Int

  """The error message."""
  message: String
}

type Category implements Node {
  id: ID!
  name: String!
  slug: String
  vehicles(after: String, before: String, first: Int, last: Int): VehicleCountableConnection
}

"""Deletes categories."""
type CategoryBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type CategoryCountableConnection {
  edges: [CategoryCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type CategoryCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Category!
}

type CategoryCreate {
  category: Category
  errors: [Error!]!
}

type CategoryDelete {
  category: Category
  errors: [Error!]!
}

input CategoryFilterInput {
  search: String
}

input CategoryInput {
  name: String
  slug: String
}

enum CategorySortField {
  NAME
}

input CategorySortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort categories by the selected field."""
  field: CategorySortField!
}

type CategoryUpdate {
  category: Category
  errors: [Error!]!
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

input DateRangeInput {
  """Start date."""
  gte: Date

  """End date."""
  lte: Date
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

type Document implements Node {
  beginDate: Date
  created: DateTime
  description: String
  expirationDate: Date
  expired: Boolean
  expires: Boolean
  file: File
  id: ID!
  isPublished: Boolean
  name: String!
  provider: Provider
  publicationDate: Date
  updated: DateTime
  vehicle: Vehicle
}

"""Deletes segments."""
type DocumentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type DocumentCountableConnection {
  edges: [DocumentCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type DocumentCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Document!
}

type DocumentCreate {
  document: Document
  errors: [Error!]!
}

type DocumentDelete {
  document: Document
  errors: [Error!]!
}

input DocumentFilterInput {
  beginDate: DateRangeInput
  expirationDate: DateRangeInput
  expires: Boolean
  isPublished: Boolean
  owner: [OwnerType!]
  search: String
}

input DocumentInput {
  beginDate: Date
  description: String
  expirationDate: Date
  expires: Boolean
  file: Upload
  isPublished: Boolean
  name: String
  provider: ID
  publicationDate: Date
  vehicle: ID
}

enum DocumentSortField {
  CREATED
}

input DocumentSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort documents by the selected field."""
  field: DocumentSortField!
}

type DocumentUpdate {
  document: Document
  errors: [Error!]!
}

"""Represents an error in the input of a mutation."""
type Error {
  """The error code."""
  code: String

  """
  Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field.
  """
  field: String

  """The error message."""
  message: String
}

type File {
  url: String!
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

type Investment implements Node {
  id: ID!
  isPublished: Boolean
  items: [Item!]
  month: Int!
  year: Int!
}

"""Deletes segments."""
type InvestmentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type InvestmentCountableConnection {
  edges: [InvestmentCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type InvestmentCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Investment!
}

type InvestmentCreate {
  errors: [Error!]!
  investment: Investment
}

type InvestmentDelete {
  errors: [Error!]!
  investment: Investment
}

input InvestmentFilterInput {
  isPublished: Boolean
  month: Float
  year: Float
}

input InvestmentInput {
  isPublished: Boolean
  items: [ItemCreateInput!]
  month: Int
  year: Int
}

enum InvestmentSortField {
  CREATED
}

input InvestmentSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort investments by the selected field."""
  field: InvestmentSortField!
}

type InvestmentUpdate {
  errors: [Error!]!
  investment: Investment
}

input InvestmentUpdateInput {
  addItems: [ItemCreateInput!]
  isPublished: Boolean
  month: Int
  removeItems: [ID!]
  year: Int
}

type Item implements Node {
  id: ID!
  investment: Investment
  name: String!
  value: Decimal
}

type ItemBulkCreate {
  errors: [BulkItemError!]!
  items: [Item]
}

input ItemBulkInput {
  name: String
  value: Float
}

type ItemCreate {
  errors: [Error!]!
  investment: Item
  item: Item
}

input ItemCreateInput {
  name: String!
  value: Float!
}

type ItemDelete {
  errors: [Error!]!
  item: Item
}

input ItemInput {
  investment: ID
  name: String
  value: Float
}

type ItemUpdate {
  errors: [Error!]!
  item: Item
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

type Mutation {
  """Deletes categories."""
  categoryBulkDelete(
    """List of category IDs to delete."""
    ids: [ID!]!
  ): CategoryBulkDelete
  categoryCreate(input: CategoryInput!): CategoryCreate
  categoryDelete(id: ID): CategoryDelete
  categoryUpdate(id: ID, input: CategoryInput!): CategoryUpdate

  """Deletes segments."""
  documentBulkDelete(
    """List of documents IDs to delete."""
    ids: [ID!]!
  ): DocumentBulkDelete
  documentCreate(input: DocumentInput!): DocumentCreate
  documentDelete(id: ID): DocumentDelete
  documentUpdate(id: ID, input: DocumentInput!): DocumentUpdate

  """Deletes segments."""
  investmentBulkDelete(
    """List of segments IDs to delete."""
    ids: [ID!]!
  ): InvestmentBulkDelete
  investmentCreate(input: InvestmentInput!): InvestmentCreate
  investmentDelete(id: ID): InvestmentDelete
  investmentUpdate(id: ID, input: InvestmentUpdateInput!): InvestmentUpdate
  itemBulkCreate(investmentId: ID, items: [ItemBulkInput]!): ItemBulkCreate
  itemCreate(input: ItemInput!, investmentId: ID!): ItemCreate
  itemDelete(id: ID): ItemDelete
  itemUpdate(id: ID, input: ItemInput!): ItemUpdate

  """Deletes providers."""
  providerBulkDelete(
    """List of providers IDs to delete."""
    ids: [ID!]!
  ): ProviderBulkDelete
  providerCreate(input: ProviderInput!): ProviderCreate
  providerDelete(id: ID): ProviderDelete
  providerUpdate(id: ID, input: ProviderInput!): ProviderUpdate
  refreshToken(token: String): Refresh

  """Deletes segments."""
  segmentBulkDelete(
    """List of segments IDs to delete."""
    ids: [ID!]!
  ): SegmentBulkDelete
  segmentCreate(input: SegmentInput!): SegmentCreate
  segmentDelete(id: ID): SegmentDelete
  segmentUpdate(id: ID, input: SegmentInput!): SegmentUpdate

  """Deletes sessions."""
  sessionBulkDelete(
    """List of sessions IDs to delete."""
    ids: [ID!]!
  ): SessionBulkDelete
  sessionCreate(input: SessionInput!): SessionCreate
  sessionDelete(id: ID): SessionDelete
  sessionUpdate(id: ID, input: SessionInput!): SessionUpdate
  tokenAuth(email: String, password: String): ObtainJSONWebToken

  """Deletes vehicles."""
  vehicleBulkDelete(
    """List of vehicles IDs to delete."""
    ids: [ID!]!
  ): VehicleBulkDelete
  vehicleCreate(input: VehicleInput!): VehicleCreate
  vehicleDelete(id: ID): VehicleDelete
  vehicleUpdate(id: ID, input: VehicleInput!): VehicleUpdate
  verifyToken(token: String): Verify
}

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

type ObtainJSONWebToken {
  errors: [Error!]!
  token: String
  user: User
}

enum OrderDirection {
  """Specifies an ascending sort order."""
  ASC

  """Specifies a descending sort order."""
  DESC
}

enum OwnerType {
  PROVIDER
  VEHICLE
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

"""Represents a permission object in a friendly form."""
type Permission {
  """Internal code for permission."""
  code: String!

  """Describe action(s) allowed to do by permission."""
  name: String!
}

type Provider implements Node {
  address: String
  documentNumber: String
  documents(after: String, before: String, first: Int, last: Int): DocumentCountableConnection
  email: String
  id: ID!
  isPublished: Boolean
  name: String!
  phone: String
  segment: Segment
  slug: String
}

"""Deletes providers."""
type ProviderBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type ProviderCountableConnection {
  edges: [ProviderCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type ProviderCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Provider!
}

type ProviderCreate {
  errors: [Error!]!
  provider: Provider
}

type ProviderDelete {
  errors: [Error!]!
  provider: Provider
}

input ProviderFilterInput {
  closeToExpire: Boolean
  expired: Boolean
  isPublished: Boolean
  search: String
  segment: ID
  segments: [ID!]
}

input ProviderInput {
  address: String
  documentNumber: String
  email: String
  isPublished: Boolean
  name: String
  phone: String
  publicationDate: Date
  segment: ID
  slug: String
}

enum ProviderSortField {
  CREATED
  NAME
  PUBLISHED
  UPDATED
}

input ProviderSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort providers by the selected field."""
  field: ProviderSortField!
}

type ProviderUpdate {
  errors: [Error!]!
  provider: Provider
  vehicle: Provider
}

type Query {
  categories(after: String, before: String, filter: CategoryFilterInput, first: Int, last: Int, sortBy: CategorySortingInput): CategoryCountableConnection
  category(id: ID, slug: String): Category
  document(id: ID): Document
  documents(after: String, before: String, filter: DocumentFilterInput, first: Int, last: Int, sortBy: DocumentSortingInput): DocumentCountableConnection
  investment(id: ID, month: Int, year: Int): Investment
  investments(after: String, before: String, filter: InvestmentFilterInput, first: Int, last: Int, sortBy: InvestmentSortingInput): InvestmentCountableConnection
  me: User
  provider(id: ID, slug: String): Provider
  providers(after: String, before: String, filter: ProviderFilterInput, first: Int, last: Int, sortBy: ProviderSortingInput): ProviderCountableConnection
  segment(id: ID, slug: String): Segment
  segments(after: String, before: String, filter: SegmentFilterInput, first: Int, last: Int, sortBy: SegmentSortingInput): SegmentCountableConnection
  session(id: ID, slug: String): Session
  sessions(after: String, before: String, filter: SessionFilterInput, first: Int, last: Int, sortBy: SessionSortingInput): SessionCountableConnection
  vehicle(id: ID, slug: String): Vehicle
  vehicles(after: String, before: String, filter: VehicleFilterInput, first: Int, last: Int, sortBy: VehicleSortingInput): VehicleCountableConnection
}

type Refresh {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
}

type Segment implements Node {
  id: ID!
  name: String!
  providers(after: String, before: String, first: Int, last: Int): ProviderCountableConnection
  slug: String
}

"""Deletes segments."""
type SegmentBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type SegmentCountableConnection {
  edges: [SegmentCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type SegmentCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Segment!
}

type SegmentCreate {
  errors: [Error!]!
  segment: Segment
}

type SegmentDelete {
  errors: [Error!]!
  segment: Segment
}

input SegmentFilterInput {
  search: String
}

input SegmentInput {
  name: String
  slug: String
}

enum SegmentSortField {
  NAME
}

input SegmentSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort segments by the selected field."""
  field: SegmentSortField!
}

type SegmentUpdate {
  errors: [Error!]!
  segment: Segment
}

type Session implements Node {
  content: JSONString
  date: DateTime
  id: ID!
  isPublished: Boolean
  name: String!
  slug: String
}

"""Deletes sessions."""
type SessionBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type SessionCountableConnection {
  edges: [SessionCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type SessionCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Session!
}

type SessionCreate {
  errors: [Error!]!
  session: Session
}

type SessionDelete {
  errors: [Error!]!
  session: Session
}

input SessionFilterInput {
  isPublished: Boolean
  search: String
}

input SessionInput {
  content: JSONString
  date: DateTime
  isPublished: Boolean
  name: String
  slug: String
}

enum SessionSortField {
  NAME
}

input SessionSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort sessions by the selected field."""
  field: SessionSortField!
}

type SessionUpdate {
  errors: [Error!]!
  session: Session
  vehicle: Session
}

"""
Create scalar that ignores normal serialization/deserialization, since
that will be handled by the multipart request spec
"""
scalar Upload

type User implements Node {
  email: String!
  firstName: String
  id: ID!
  isStaff: Boolean
  lastName: String
  permissions: [Permission]
}

type Vehicle implements Node {
  address: String
  category: Category
  documentNumber: String
  documents(after: String, before: String, first: Int, last: Int): DocumentCountableConnection
  email: String
  id: ID!
  isPublished: Boolean
  name: String!
  phone: String
  slug: String
}

"""Deletes vehicles."""
type VehicleBulkDelete {
  """Returns how many objects were affected."""
  count: Int!
  errors: [Error!]!
}

type VehicleCountableConnection {
  edges: [VehicleCountableEdge!]!

  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """A total count of items in the collection."""
  totalCount: Int
}

type VehicleCountableEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Vehicle!
}

type VehicleCreate {
  errors: [Error!]!
  vehicle: Vehicle
}

type VehicleDelete {
  errors: [Error!]!
  vehicle: Vehicle
}

input VehicleFilterInput {
  categories: [ID!]
  category: ID
  isPublished: Boolean
  search: String
}

input VehicleInput {
  address: String
  category: ID
  documentNumber: String
  email: String
  isPublished: Boolean
  name: String
  phone: String
  publicationDate: Date
  slug: String
}

enum VehicleSortField {
  CREATED
  NAME
  PUBLISHED
  UPDATED
}

input VehicleSortingInput {
  """Specifies the direction in which to sort products."""
  direction: OrderDirection!

  """Sort vehicles by the selected field."""
  field: VehicleSortField!
}

type VehicleUpdate {
  errors: [Error!]!
  vehicle: Vehicle
}

type Verify {
  payload: GenericScalar!
}